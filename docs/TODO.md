# TODO: Критические проблемы и направления решений

Этот документ фиксирует критические проблемы текущей реализации event-bus
в реалистичном использовании LCMM, а также возможные пути их решения.

## 1) Потеря событий при падении процесса (приоритет №1)

Проблема:
- Шина работает in-process и не имеет долговечного журнала.
- Если приложение падает после коммита в БД, но до обработки событий всеми
  подписчиками, возникает частичная видимость: один модуль знает о сущности,
  другой — нет.

Возможные направления решения:
- Outbox pattern: писать событие в outbox-таблицу в той же транзакции,
  а затем публиковать асинхронно из outbox.
- Durable queue / event log: персистентный журнал (таблица, Kafka, Rabbit),
  поддержка повторной доставки.
- Идемпотентные обработчики и дедупликация по `message-id`.
- Фоновые сверки/догоняющие процессы для выравнивания состояния.

## 2) Логгер может ломать критический путь

Проблема:
- `log!` вызывается без `try/catch`. Если логгер выбросит исключение,
  `publish` падает и может сорвать критический путь.

Возможные направления решения:
- Обернуть вызов логгера в `try/catch` и превращать ошибки в безопасный no-op.
- Логировать факт падения логгера через отдельный `:logger-failure` event.
- Рассмотреть ограниченный асинхронный режим логирования.

## 3) Частичная доставка в buffered-режиме при переполнении

Проблема:
- В `:buffered` режиме при заполнении очереди `submit-task` бросает исключение.
  Это может произойти после того, как часть обработчиков уже поставлена в очередь:
  часть подписчиков получит событие, часть — нет.

Возможные направления решения:
- Реализовать доставку "всё или ничего" (атомарное резервирование места).
- Добавить режим `:delivery :all-or-nothing | :best-effort`.
- Блокировать публикацию с таймаутом, а не падать мгновенно.

## 4) Buffered-режим фактически не использует virtual threads

Проблема:
- В `:buffered` ветке используется `future`, который работает на обычном пуле,
  а не на virtual threads.

Возможные направления решения:
- Заменить `future` на задачи через виртуальный `executor`.
- Использовать выделенный пул виртуальных потоков-потребителей.
- Явно проверять использование virtual threads в тестах.

## 5) CausationPath: важно сохранить порядок и политику циклов

Проблема:
- `:causation-path` должен сохранять порядок, чтобы трассировка цепочки была
  воспроизводимой и читаемой.
- Политика циклов должна быть прозрачной (сейчас цикл определяется по паре
  `(Module, MessageType)`).

Текущее решение:
- `:causation-path` хранится как вектор пар `[module event-type]`.
- Цикл детектируется по повтору пары `(module, event-type)`.
- Ограничение глубины по `max-depth` сохранено.

## 6) Нет валидации на publish (только на subscribe)

Проблема:
- Требования требуют валидации на входе (`publish`) и на выходе (`subscribe`),
  но сейчас валидация выполняется только на уровне подписчика.

Возможные направления решения:
- Ввести реестр типов событий с канонической схемой.
- Валидировать `payload` в `publish` по этой схеме.
- Оставить per-subscriber валидацию для дополнительных ограничений.
